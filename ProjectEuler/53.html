<html>
<head>
    <title>53</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="Stylesheet" type="text/css" href="../assets/styles/style.css" />
    <script src="../assets/js/jquery.js" type="text/javascript"></script>
    <script>
        var root_path = "../";
    </script>

</head>
<body>
    <div id="all">
        <div id="header"></div>
        <div id="main">
            
<h1 id="toc_1">Project Euler Problem 53</h1>

<h2 id="toc_1.1">Description</h2>
<p>
There are exactly ten ways of selecting three from five, 12345:
</p>
<pre>
123, 124, 125, 134, 135, 145, 234, 235, 245, and 345
</pre>
<p>
In combinatorics, we use the notation, \( ^5C_3 = 10 \).
</p>

<p>
In general,
</p>
\[
^nC_r = \frac{n!}{r!(n-r)!} \text{ , where $r&lt;=n$, $n!=n*(n-1)*...*3*2*1$, and $0!=1$.}
\]
<p>
It is not until n = 23, that a value exceeds one-million: \(^{23}C_{10} = 1144066\).
</p>

<p>
How many, not necessarily distinct, values of  \(^nC_r\), for 1 &lt;= n &lt;= 100, are greater than one-million?
</p>

<h2 id="toc_1.2">Solution</h2>
<p>
对于排列数，我们知道其具有对称性，当C(n,r)中的r为n的中值为，C(n,r)的值最大，以该r值为中心，C(n,r)的值向两边递减，所以要算当n等于某值时，C(n,r)中有几个值大于100万，只要另r从1开始计算到第一个大于100万的值，通过对称性即可求出总的有几个值大于100万，而不需要遍历整个所有小于n的r值。
</p>

<p>
关于求C(n,r)的值，对于该题，由于数据量不大，可以直接根据上述公式求解，也可以根据递推公式C(n,r) = C(n-1,r-1) + C(n-1,r)，用这种方法，可以省去乘法和除法的开销，速度会更快。上述第二种方法，在这道题里，只需开一个一维数组记录C(n,r)的值，用另外一个递推公式则可以不用数组，即\( ^nC_{r+1}=\frac{n-r}{r+1}*{^nC_r} \)
</p>

<hr />
<p>
<code>History</code>: 2012-03-23 17:33 add.
</p>

        </div>
        <div id="sidebar"></div>
        <div id="footer"></div>
    </div>
    <script src="../assets/js/itcbxwiki.js" type="text/javascript"></script>
</body>
</html>
